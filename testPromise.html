<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    class MyPromise {
        constructor(executor) {
            // 初始化
            this.initValue();
            // 初始化this绑定
            this.initBind();
            // 执行Promise构造函数传进来的函数，try/catch是对throw方法错误异常的处理
            try {
                executor(this.resolve, this.reject)
            } catch (e) {
                this.reject(e)
            }
        }
        // 初始化方法
        initValue() {
            this.PromiseResult = null;
            this.PromiseState = 'pending'
        }
        // 初始化this绑定的方法
        initBind() {
            // 将原型对象的方法始终绑定在实例上
            this.resolve = this.resolve.bind(this)
            this.reject = this.reject.bind(this)
        }
        // resolve方法
        resolve(value) {
            // 这里实现了Promise对象无法改变的功能
            if (this.PromiseState !== 'pending') return
            this.PromiseState = 'resolved';
            this.PromiseResult = value;
        }
        // reject方法
        reject(reason) {
            if (this.PromiseState !== 'pending') return
            this.PromiseState = 'rejected'
            this.PromiseResult = reason
        }
    }
    const test1 = new MyPromise((resolve, reject) => {
        resolve('成功')
    })
    console.log(test1)
    const test2 = new MyPromise((resolve, reject) => {
        reject('失败')
    })
    console.log(test2)
    // 但是Promise状态是一旦改变就不能发生变化的，上述代码无法定下Promise的状态
    //所以需要加一个状态判断
    const test3 = new MyPromise((resolve, reject) => {
        reject('失败')
        resolve('成功')
    })
    console.log(test3)
    // 但是Promise中有throw的话，相当于执行了reject.
    // 此时，就要执行try/catch方法了
    const test4 = new MyPromise((resolve, reject) => {
        throw ('失败')
    })
    console.log(test4)
</script>

</html>