<script>
// 13.1 概述
// Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，元编程，对变成语言进行编程
// Proxy可以理解成，在目标对象假设一层“拦截”，外界对该对象的访问，都要通过这层拦截，对外界的访问进行过滤和改写
// Proxy原意为Proxy，即用来代理某些操作
// var obj = new Proxy({}, {
//     get: function (target, propKey, receiver) {
//         console.log(`getting ${propKey}!`);
//         return Reflect.get(target, propKey, receiver);
//     },
//     set: function (target, propKey, value, receiver) {
//         console.log(`setting ${propKey}!`);
//         return Reflect.set(target, propKey, value, receiver);
//     }
// });
// // 设置了getter和setter
// obj.count = 1
// //  setting count!
// ++obj.count
// //  getting count!
// //  setting count!
// //  2
// // es6原生提供Proxy构造函数，用来生成Proxy实例。
// //   var proxy=new Proxy(target,handler)
// // Proxy()表示生成一个Proxy实例，target参数表示索要拦截的目标对象，handler参数也是一个对象
// // 拦截读取属性行为的例子
// var proxy = new Proxy({}, {
//     get: function (target, propKey) {
//         return 35;
//     }
// });
// proxy.time //35
// proxy.name //35
// proxy.title //35
//   // Proxy对象接受两个参数，
//   // 第一个参数是所要代理的目标对象
//   // 第二个参数一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，
//   // 如上代码就拦截了对目标对象属性的访问请求。
//   // 要Proxy起作用，必须对Proxy实例起作用，而不是对目标对象进行操作

// // 如果handler没有设置任何拦截，那就等同于直接通向原对象
// var target = {}
// var handler = {}
// var proxy = new Proxy(target, handler)
// proxy.a = 'b'
// console.log(target.a)

// // 另一个技巧将Proxy对象，设置到object.proxy属性，从而可以在对象上调用
// var object = { proxy: new Proxy(target, handler) }
// // Proxy实例也可以作为其他对象的原型对象
// var proxy = new Proxy({}, {
//     get: function (target, propKey) {
//         return 35
//     }
// })
// let obj1 = Object.create(proxy)
// console.log(obj1.time)

// 上面代码中，proxy对象是obj对象的原型
// obj对象本身并没有time属性，根据原型链会找到原型对象上的属性
// Proxy支持的拦截操作一览，一共有13种
// get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
// set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
// has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
// deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
// ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
// getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
// defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
// preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
// getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
// isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
// setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
// apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
// construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。

// 13.2 Proxy实例的方法
// (1) get() get方法用于拦截某个属性的读取操作
// 可以接受三个参数，依次为目标对象，属性名和proxy实例本身
// var person = {
//     name: '张三'
// }
// var proxy = new Proxy(person, {
//     get: function (target, propKey) {
//         if (propKey in target) {
//             return target[propKey];
//         } else {
//             throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.")
//         }
//     }
// })
// console.log(proxy.name) //"张三"
// // console.log(proxy.age) // does not exist

// // get方法可以继承
// let proto = new Proxy({}, {
//     get(target, propertyKey, receiver) {
//         console.log('GET' + propertyKey)
//         return target[propertyKey]
//     }
// })
// let obj = Object.create(proto)
// console.log(obj.foo)// 属性值为undefined

// // 可以使用get拦截，实现读取负数的索引
// function createArray(...elements) {
//     let handler = {
//         get(target, propKey, receiver) {
//             let index = Number(propKey);//这里拿到是index索引号
//             if (index < 0) {
//                 propKey = String(target.length+index)
//             }
//             return Reflect.get(target, propKey, receiver)
//         }
//     }
//     let target = []
//     target.push(...elements)
//     return new Proxy(target,handler)
// }
// let arr = createArray('a', 'b', 'c')
// console.log(arr[-1])

// // 利用Proxy，可以将读取属性的操作(get),转变为执行某个函数
// // 从而实现属性的链式操作
// var pipe = function (value) {
//   var funcStack = [];
//   var oproxy = new Proxy({} , {
//     get : function (pipeObject, fnName) {
//       if (fnName === 'get') {
//         console.log('执行了get')
//         return funcStack.reduce(function (val, fn) {
//           return fn(val);
//         },value);
//       }
//       console.log(fnName)
//       console.log(window[fnName])
//       funcStack.push(window[fnName]);
//       return oproxy;
//     }
//   });

//   return oproxy;
// }

// var double = n => n * 2;
// var pow    = n => n * n;
// var reverseInt = n => n.toString().split("").reverse().join("") | 0;

// console.log(pipe(3).double.pow.get); // 63

// const proxy1 = new Proxy({}, {
//   get: function(target, key, receiver) {
//     return receiver;
//   }
// });

// const d = Object.create(proxy);
// d.a === d // true

// (2) set()方法
// set方法用来拦截某个属性的赋值操作，可以接受四个参数
// 依次为目标对象，属性名，属性值和Proxy实例本身，最后一个参数可选
// let validator={
//   set: function(obj,prop,value){
//     if(prop==='age'){
//       if(!Number.isInteger(value)){
//         throw new TypeError('The age is not an integer')
//       }
//       if(value>200){
//         throw new RangeError('The age seems invalid')
//       }
//     }
//     obj[prop]=value;
//     return true
//   }
// }
// let person1=new Proxy({},validator)

// console.log(person1.age=100);
// // 有时候对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示属性不应该被外部使用
// const handler={
//   get(target,key){
//     invariant(key,'get')
//     return target[key];
//   },
//   set(target,key,value){
//     invariant(key,'set')
//     target[key]=value;
//     return true
//   }
// }
// function invariant(key,action){
//   if(key[0]==='_'){
//     throw new Error(`Invalid attempt to ${action} private "${key}" property`)
//   }
// }
// const target={}
// const proxy2=new Proxy(target,handler);
// console.log(proxy2._prop)// 报错

// const handler1={
//   set: function(obj,prop,value,receiver){
//     obj[prop]=receiver;
//     return true
//   }
// };
// const proxy3=new Proxy({},handler1)
// proxy3.foo='bar';
// console.log(proxy3.foo===proxy3)

// (3) apply()
// apply方法可以接受三个参数，分别是目标对象的上下文对象和目标对象的参数数组
// var twice = {
//   apply (target, ctx, args) {
//     console.log(target)
//     console.log(...args)
//     console.log(...arguments)// 执行的函数和参数
//     console.log(Reflect)
//     return Reflect.apply(...arguments) * 2;
//   }
// };
// function sum (left, right) {
//   return left + right;
// };
// var proxy = new Proxy(sum, twice);
// proxy(1, 2) // 6
// proxy.call(null, 5, 6) // 22
// proxy.apply(null, [7, 8]) // 30

// (4) has()方法
// has()方法用来拦截HasProperty操作，判断对象是否具有某个属性
// has()方法可以接受两个参数，分别是目标对象、需查询的属性名。
// 如果原对象不可配置或者禁止扩展，这时has()拦截会报错。
// 另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。

// (5) construct()方法
// construct()方法用于拦截new命令，下面是拦截对象的写法。
// const handler = {
//   construct (target, args, newTarget) {
//     return new target(...args);
//   }
// };
// construct()方法返回的必须是一个对象，否则会报错。
// 另外，由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。
// const p = new Proxy({}, {
//   construct: function(target, argumentsList) {
//     return {};
//   }
// });

// new p() // 报错
// // Uncaught TypeError: p is not a constructor
// 注意，construct()方法中的this指向的是handler，而不是实例对象。

// (6) deleteProperty()方法
// 用于拦截delete操作
// var handler = {
//   deleteProperty (target, key) {
//     invariant(key, 'delete');
//     delete target[key];
//     return true;
//   }
// };
// function invariant (key, action) {
//   if (key[0] === '_') {
//     throw new Error(`Invalid attempt to ${action} private "${key}" property`);
//   }
// }

// var target = { _prop: 'foo' };
// var proxy = new Proxy(target, handler);
// delete proxy._prop
// // Error: Invalid attempt to delete private "_prop" property

// 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。
// defineProperty()
// defineProperty()方法拦截了Object.defineProperty()操作
// var handler = {
//   defineProperty (target, key, descriptor) {
//     return false;
//   }
// };
// var target = {};
// var proxy = new Proxy(target, handler);
// proxy.foo = 'bar' // 不会生效
// 添加新属性是无效的。此外，这里的false只是用来提示操作失败，不能阻止添加新的属性
// 如果某个属性不能不可写或不可配置，则defineProperty()方法不可以改变这两个设置。


// getOwnPropertyDescriptor()
// 用于返回一个属性描述对象或者undefined
// var handler = {
//   getOwnPropertyDescriptor (target, key) {
//     if (key[0] === '_') {
//       return;
//     }
//     return Object.getOwnPropertyDescriptor(target, key);
//   }
// };
// var target = { _foo: 'bar', baz: 'tar' };
// var proxy = new Proxy(target, handler);

// getPrototypeOf()
// getPrototypeOf()方法主要用于拦截获取对象原型。
// var proto = {};
// var p = new Proxy({}, {
//   getPrototypeOf(target) {
//     return proto;
//   }
// });
// Object.getPrototypeOf(p) === proto // true

// isExtensible()
// isExtensible()方法拦截Object.isExtensible()操作
// 为对象添加新的属性
// var p = new Proxy({}, {
//   isExtensible: function(target) {
//     console.log("called");
//     return true;
//   }
// });

// console.log(Object.isExtensible(p))
// "called"
// true
// 这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致
// var p = new Proxy({}, {
//   isExtensible: function(target) {
//     return false;
//   }
// });

// console.log(Object.isExtensible(p)) //抛出错误，应该设为true


// ownKeys()
// ownKeys()方法用来拦截对象自身属性的读取操作。
// Object.getOwnPropertyNames()
// Object.getOwnPropertySymbols()
// Object.keys()
// for...in循环
let target={
  a:1,
  b:2,
  c:3
}
let handler={
  ownKeys(target){
    return ['a']
  }
}
let proxy=new Proxy(target,handler);

console.log(Object.keys(proxy))
// 在使用Object.keys()方法时，有三类属性会被ownKeys()方法，不会返回。
// 目标对象上不存在的属性
// 属性名为Symbol值
// 不可遍历的属性
// ownKeys()方法还可以拦截Object.getOwnPropertyNames()
// for...in循环也受到ownKeys()方法的拦截。
// ownKeys()方法返回的数组成员，只能是字符串或者Symbol值
// 另外，如果目标对象是不可扩展的，这时ownKeys()方法返回的数组之中
// 必须包含对象的所有属性，且不能包含多余的属性，否则报错
// var obj = {
//   a: 1
// };

// Object.preventExtensions(obj);

// var p = new Proxy(obj, {
//   ownKeys: function(target) {
//     return ['a', 'b'];
//   }
// });

// Object.getOwnPropertyNames(p)


</script>

