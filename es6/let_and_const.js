// 1.1 let命令

// for(let i=0;i<10;i++){
//     console.log('哟西')
// }
// console.log(i) //i is not defined

// var a=[];
// for(var i=0;i<10;i++){
//     a[i]=function(){
//         console.log(i);
//     }
// }
// a[6]()//打印结果为10，因为这里的i时全局变量

// var a=[];
// for(let i=0;i<10;i++){
//     a[i]=function(){
//         console.log(i);
//     }
// }
// //因为这里的i是局部变量，每次循环都生成了新的i，js引擎每次都会记住上一次的循环的值，进而在此基础上进行累加
// a[6]()//打印结果为6

// for语句循环有一个特别之处，
// 在于设置循环变量的那一部分是父级作用域，而循环体内部是子级作用域
// for(let i=0;i<3;i++){
//     let i='abc';
//     console.log(i);
// }

// 注意点 let变量变量不存在变量提升的这种现象。
// 声明的变量只能在，声明之后使用

// 只要会计作用域内存在let命令，它所声明的变量就是“绑定”
// 不会再收到外部的影响
// var tmp=123;
// if(true){
//     temp='abc'
//     let temp //ReferenceError: Cannot access 'temp' before initialization
// }

// 在代码块内，使用let命令声明变量之前，该变量都是不可用的，这个现象称为暂时性死区
// 暂时性死区的出现意味着typeof不再是一个100per安全的操作
// 记住一句话：变量一定要在声明之后使用，否则就报错

// function bar(x=2,y=x){
//     return [x,y]
// }
// let i=bar()
// console.log(i)//[2,2]

// 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是是不可获取的
// 只有等到声明变量的哪一行代码出现，才可以使用或获取该变量

console.log('--------------------------------------------')

// 1.2 块级作用域
// 块级作用域可以用来解决 1.内层变量会覆盖外层变量 2.用来计数的循环变量泄露为全局变量

// 避免再块级作用域中声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
// 推荐如下写法
{
    let a='secret';
    let f=function(){
        return a;
    }
}
// es6的块级作用域必须有大括号
console.log('-----------------------------')
// 1.3 const命令

// const声明一个只读的常量。一旦声明，常量的值就不能发生改变
// const一旦声明变量，就必须立即初始化，不能留到以后赋值
// const的作用域与let命令相同：只再声明所在的块级作用域内有效
// const命令声明的常量也是不能提升，存在暂时性死区，只能再声明的位置后面使用
// const声明的常量与let一样不可以重复声明
console.log('--------------------------------------------')
// const实际上保证的，不是变量的值不得改动
// 而是变量指向的那个内存地址所保存的数据不能改动
// 对于简单类型的数据（数值，字符串，布尔值），值就保存在变量指向的那个内存地址中，因此等同于常量
// 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址
// const只能保证这个指针是固定的（即总是指向另一个固定的地址）
// 至于它指向的数据结构发生了变化，是不能控制的
// 相当于把foo看成一个指针，指向一个地址
// const foo={}
// foo.prop = 123;
// foo = {} // TypeError:"foo" is read-only

// 冻结了这个对象，向这个对象添加属性起不了作用
const foo = Object.freeze({})

// 除了将对象本身冻结，对象的属性也可以冻结

// es6声明一共有6种方法
// var function let const import class

var a = 1;
this.a

let b = 1;
this.b
console.log(this.a)
console.log(this.b)
console.log(globalThis)
// ES2020语言标准中，引入了globalThis座位顶层对象。
// globalThis都存在，都可以从它拿到顶层对象，指向全局环境下的this